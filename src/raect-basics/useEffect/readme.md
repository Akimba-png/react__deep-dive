# useEffect

`useEffect( setupFn, dependencies? )`  

useEffect это хук, который позволяет выполнять в компоненте сайд-эффекты.  
Например манипулировать с dom-node или подключить компоненет к внешней,  
не подконтольной реакту системе, выполнять сетевые запросы.  
Сюда же можно относить таймеры, подписку на события (особенно на события  
window), старт анимации внешних библиотек, работу с DOM  

Effects are an “escape hatch”: you use them when you need to “step outside  
React” and when there is no better built-in solution for your use case.  

## Этапы рендера функционального компонента

Как правило, useEffect выполняется после того как браузер отрендерит страницу,  
но в редких случаях может быть вызван и до отрисовки браузером.  

1. Вызов компонента (при первом рендере refы === null);
2. useState вычисляет и возвращает новое значение стейна  
   вызываются setState из очереди;
3. Обновляется virtul dom и dom (на экране ещё ничего не отрисовано,  
   но dom сформирован и refы доступны);
4. useLayoutEffect();
5. Render() React передаёт управление браузеру и тот отрисовывает страницу;
6. Вызывается callback отмонтирования useEffectа из прошлого рендера;
7. useEffect() текущего нового рендера;

## Сигнатура useEffect

setupFn - функция, которая содержит логику эффекта.  
Вызывается на первый рендер (после отрисовки страницы браузером) и на все  
последующие ререндеры при изменении зависимостей если они указаны,  
или если их нет  

cleanupFn - setupFn опционально может возвращать cb cleanup,  
которая будет очищать эффект текущего рендера (н-р удалять обработчики  
событий) Cleanup вызывается на этапе следующего рендера, после отрисовки  
браузером, но перед вызовом нового useEffectа, при этом в своём теле cleanup  
использует state и props из прошлого рендера  

dependencies - в dependencies добавляют все зависимости которые используются  
в теле useEffect, включая props, state, все переменные и фукнции объявленные  
внутри тела компонента. Чтобы функции из тела компонента не вызывали вызов  
useEffect на каждый ререндер стоит их обернуть в useCallback  

useEffect возвращает undefined  

## useEffect vs useLayoutEffect

useLayoutEffect вызывается до useEffect и перед отрисовкой или перерисовкой  
экрана (т.е. когда на экране ещё старые данные) но после того как dom  
сформирован  
Это даёт возможность провести какие-либо манипуляции с ui скрытно от  
пользователя (например вычислить высоту popovera, которая зависит от его  
содержимого и начально не известна)  

useEffect как правило, вызывается после отрисовки браузером экрана  
Однако это поведение не всегда гарантировано.  
Возможный случаи когда useEffect сработает перед отрисовкой экрана  
useEffect может сработать до перерисовки в случаях, когда компонент  
использует и useEffect и useLayoutEffect, при этом в useLayoutEffect  
происходит обновление стейта

Обновление useEffect до момента репейнта может приводить к миганиям и  
промежуточным перерисовкам на экране, что снизит ux пользователя  

### Выводы

1. Если useEffect делает что-либо визуальное (например позиционирование  
   тултипа) и его смещение заметно, то эффект следует перенести  
   в useLayoutEffect  
2. Не стоит всегда полагаться, что useEffect будет вызван после render  
   useLayoutEffect можно использовать для вычисления размеров элемента,  
   если они заранее не известны  
3. useLayoutEffect может снизить производительность, лучше использовать  
   useEffect где это возможно  
4. Обновление стейта внутри useLayoutEffect может привести к неожиданным  
   вызовами useEffect  
5. Важно помнить, что useLayoutEffect блокирует браузерный рендеринг,  
   что снижает производительность  

## useInsertionEffect

Срабатывает до всех прочих эффектов  
Может сработать как до так и после обновления / построения DOM  
Срабатывает до привязки ref  
Не даёт возможность использовать обновления стейта внутри себя  
Используется для автором css-in-js библиотек и позволяет вставить в dom  
элементы, до того момента как сработает любой из других эффектов  




## Эффекты состояния и пропсы

Эффекты всегда видят пропсы и состояния из того рендера,  
в котором они объявлены.  
Стейты и пропсы, внутри каждого рендера, являются константой  
и со временем не меняются.  

React вызывает компонент всякий раз, при обновлении стейта или пропсов.  
Компонент меняется и при каждом рендере вызывается снова и снова.  
При этом каждый рендер «видит» собственное значение стейта и пропсов,  
которое оказывается изолированным для каждой из операций рендеринга.  

Так же обработчики событий и другие ассинхронные операции, которые в своём коде  
ссылаются на значения стейта или пропсов, при своём исполнении будут  
использовать те варианты стейтов и пропсов, которые будут доступны им  
из замыкания. Т.е. те варианты, которые обработчики видели при своём объявлении  
(а не текущее их значение)  

Это связано с тем что useState не мутирует значение стейта, а для каждого  
рендера создаётся своё константное уникальное значение.  
Это отличает useState от setState в классовых компонентах  
(т.к. setState мутирует значение стейта)  
Чтобы в функциональных компонентах добиться поведения setState классовых  
компонентов, следует использовать useRef, значение которого мутируется  
и передаётся из рендера в рендер.  

Callback`и отмонтирования (функции возвращаемые из useEffect) так же видят  
те значения стейта, которые были актуальны на момент того варианта рендера,  
внутри которого useEffect был объявлен  
Но вызывается callback отмонтирования, после этапа рендера нового компонента,  
но перед вызовом useState  





