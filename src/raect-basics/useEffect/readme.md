# useEffect

`useEffect( setupFn, dependencies? )`  

useEffect это хук, который позволяет выполнять в компоненте сайд-эффекты.  
Например манипулировать с dom-node или подключить компоненет к внешней,  
не подконтольной реакту системе, выполнять сетевые запросы.  
Сюда же можно относить таймеры, подписку на события (особенно на события  
window), старт анимации внешних библиотек, работу с DOM  

Effects are an “escape hatch”: you use them when you need to “step outside  
React” and when there is no better built-in solution for your use case.  

## Этапы рендера функционального компонента

Как правило, useEffect выполняется после того как браузер отрендерит страницу,  
но в редких случаях может быть вызван и до отрисовки браузером.  

1. Вызов компонента (при первом рендере refы === null);
2. useState вычисляет и возвращает новое значение стейна  
   вызываются setState из очереди;
3. Обновляется virtul dom и dom (на экране ещё ничего не отрисовано,  
   но dom сформирован и refы доступны);
4. useLayoutEffect();
5. Render() React передаёт управление браузеру и тот отрисовывает страницу;
6. Вызывается callback отмонтирования useEffectа из прошлого рендера;
7. useEffect() текущего нового рендера;

## Сигнатура useEffect

setupFn - функция, которая содержит логику эффекта.  
Вызывается на первый рендер (после отрисовки страницы браузером) и на все  
последующие ререндеры при изменении зависимостей если они указаны,  
или если их нет  

cleanupFn - setupFn опционально может возвращать cb cleanup,  
которая будет очищать эффект текущего рендера (н-р удалять обработчики  
событий) Cleanup вызывается на этапе следующего рендера, после отрисовки  
браузером, но перед вызовом нового useEffectа, при этом в своём теле cleanup  
использует state и props из прошлого рендера  

dependencies - в dependencies добавляют все зависимости которые используются  
в теле useEffect, включая props, state, все переменные и фукнции объявленные  
внутри тела компонента. Чтобы функции из тела компонента не вызывали вызов  
useEffect на каждый ререндер стоит их обернуть в useCallback  

useEffect возвращает undefined  

## useEffect vs useLayoutEffect

useLayoutEffect вызывается до useEffect и перед отрисовкой или перерисовкой  
экрана (т.е. когда на экране ещё старые данные) но после того как dom  
сформирован  
Это даёт возможность провести какие-либо манипуляции с ui скрытно от  
пользователя (например вычислить высоту popovera, которая зависит от его  
содержимого и начально не известна)  

useEffect как правило, вызывается после отрисовки браузером экрана  
Однако это поведение не всегда гарантировано.  
Возможный случаи когда useEffect сработает перед отрисовкой экрана  
useEffect может сработать до перерисовки в случаях, когда компонент  
использует и useEffect и useLayoutEffect, при этом в useLayoutEffect  
происходит обновление стейта

Обновление useEffect до момента репейнта может приводить к миганиям и  
промежуточным перерисовкам на экране, что снизит ux пользователя  

### Выводы

1. Если useEffect делает что-либо визуальное (например позиционирование  
   тултипа) и его смещение заметно, то эффект следует перенести  
   в useLayoutEffect  
2. Не стоит всегда полагаться, что useEffect будет вызван после render  
   useLayoutEffect можно использовать для вычисления размеров элемента,  
   если они заранее не известны  
3. useLayoutEffect может снизить производительность, лучше использовать  
   useEffect где это возможно  
4. Обновление стейта внутри useLayoutEffect может привести к неожиданным  
   вызовами useEffect  
5. Важно помнить, что useLayoutEffect блокирует браузерный рендеринг,  
   что снижает производительность  

## useInsertionEffect

Срабатывает до всех прочих эффектов  
Может сработать как до так и после обновления / построения DOM  
Срабатывает до привязки ref  
Не даёт возможность использовать обновления стейта внутри себя  
Используется для автором css-in-js библиотек и позволяет вставить в dom  
элементы, до того момента как сработает любой из других эффектов  

## Эффекты состояния и пропсы

Эффекты всегда видят пропсы и состояния из того рендера,  
в котором они объявлены.  
Стейты и пропсы, внутри каждого рендера, являются константой  
и со временем не меняются.  

React вызывает компонент всякий раз, при обновлении стейта или пропсов.  
Компонент меняется и при каждом рендере вызывается снова и снова.  
При этом каждый рендер «видит» собственное значение стейта и пропсов,  
которое оказывается изолированным для каждой из операций рендеринга.  

Так же обработчики событий и другие ассинхронные операции, которые в своём коде  
ссылаются на значения стейта или пропсов, при своём исполнении будут  
использовать те варианты стейтов и пропсов, которые будут доступны им  
из замыкания. Т.е. те варианты, которые обработчики видели при своём объявлении  
(а не текущее их значение)  

Это связано с тем что useState не мутирует значение стейта, а для каждого  
рендера создаётся своё константное уникальное значение.  
Это отличает useState от setState в классовых компонентах  
(т.к. setState мутирует значение стейта)  
Чтобы в функциональных компонентах добиться поведения setState классовых  
компонентов, следует использовать useRef, значение которого мутируется  
и передаётся из рендера в рендер.  

Callback`и отмонтирования (функции возвращаемые из useEffect) так же видят  
те значения стейта, которые были актуальны на момент того варианта рендера,  
внутри которого useEffect был объявлен  
Но вызывается callback отмонтирования, после этапа рендера нового компонента,  
но перед вызовом useState  

## Fetching data inside an Effect

Загрузка данных из useEffect распростанённый паттерн, однако имеет несколько  
недостатков и может приводить к "race conditions"  

**Race conditions** - баг, который может возникать, при запросе данных  
из useEffectа. При быстром перерендере компонента внутри которого загружаются  
данные, с различными исходными данными для загрузки - загрузка данных  
произойдёт несколько раз, а итоговый результат может быть неверен т.к. из-за  
скорости сети первый отправленный запрос может придти последним, и именно он  
отразится в результате, что будет неверным.  

Чтобы этого не произошло в cleanup функции (cb отмонтирования) следует  
отменять изменение стейта при получении данных. Не нужно обновлять стейт,  
если компонет уже отмонтирован.  

### Пример корректного fetch в useEffect

```
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    let ignore = false;
    setBio(null);
    fetchBio(person).then(result => {
      if (!ignore) {
        setBio(result);
      }
    });
    return () => {
      ignore = true;
    }
  }, [person]);
```

### async / await внутри useEffect

useEffect по спецификации возвращает undefined. Поэтому применение async  
к setupFn некорректно (в этом случае она будет возвращать promise,  
что неправильно)  
Чтобы использовать async функцию внутри useEffectа нужно её объфить внутри  
него и вызвать ниже по коду  
Лучше выносить useEffect с fetch внутри в кастомный хук  

### Недостатки fetch в useEffect

1. useEffect не рендерятся на сервере (SSR) поэтому весь код приедет  
на клиент, распарсится и только потом будет fetch - это не производительно  
2. Невозможность кешировать данные. Если компонент удаляется из DOM (unmount)  
при последующем mount данные придётся загружать вновь. (при простом  
перерендере, если dependencies не изменнилсь useEffect конечно не запустится  
и повторного fetch не произойдёт) Это случиться только при удалении  
компонента из dom Например по isVisible  
3. Возможность race-conditions бага если не использовать отмену изменения  
стейта в cleanupFn  
4. Network waterfall если родительский компонент и потом его потомки  
загружают внутри себя данные - при медленном интернете это будет приводить  
к ощутимым задержкам в производительности  

### Альтернативы

1. Использование механизма загрузки данных, втроенных в фреймворки (Next)  
2. Использование инструментов загрузки, которые кешируют данные  
RTK, react-router-dom
3. Чтобы избезать networkwatefalls можно поднять слой с загрузкой данных.  
Вплоть до уровня с маршрутами  

## dependencies (reactivity rules)

В массиве зависимостей всегда следует перечислять все реактивные  
(изменяющиеся) зависимости, которые используются внутри useEffect  

Не указание в массиве зависимостей реактивных значений может привести  
к возникновению непредсказуемых багов  

useEffect без массива зависимостей - useEffect будет вызываеться на каждый  
рендер и перерендер компонента. Даже при изменении состояний, значений  
или пропсов, которые не используются внутри useEffect  

[] - useEffect будет вызван единожды при первом рендере, а cb отмонтирования  
(cleanup) будет вызван только при удалении элемента из dom  
(например по isVisible) на каждый реренден cleanup вызываться не будет.  
При этом не должно быть ситуации, когда useEffect использует внутри себя  
изменяющееся значение и оно не указано в массиве зависимостей.  
Это приведёт к багам.  

[stete1, prop1] - указание всех реактивных зависимостей, которые используются  
внутри useEffect.  

**Объекты и функции как зависимости useEffectа**  
Если внутри компонента объявляются какие-либо функции или объеты, которые  
в последстии используются внутри useEffectа, то они так же должны быть  
перечислены в массиве зависимостей.  

Однако, поскольку они объявлены внутри компонента, то на каждый перерендер  
компонента это будет новый экземпляр функций или объекта и поэтому они будут  
вызывать нежелательный вызов useEffect.  

Чтобы этого не происходило, объявление объекта или фукнции следует выносить  
за пределы компонента, или если объект использует в своём теле значение  
пропсов или стейта - переносить его объявление внутрь useEffect  
и там же его использовать  

**useEffectEvent**

Позволяет отключить вызов useEffect при изменении реактивной зависимости,  
используемой в нём  
```
useEffectEvent(
   ( reactiveValue ) => console.log( reactiveValue, nonReactiveValue )  
)
```

Хук, который вызывается на верхнем уровне компонента и возвращает переданный  
в него callback Данный cb вызывается внутри useEffect  
В данный cb выносятся все зависимости, которые не должны трригерить вызов  
основного useEffect  
Т.е. данный хук позволяет избежать вызов useEffectа при изменении  
зависимостей указанных внутри данного хука  

Т.е. если нужно использовать какие-либо изменяемые зависимости внутри  
useEffectfа, но их изменение не должно приводить к его вызову, данные  
зависимости можно поместить внутрь cb, который передаём в useEventEffect  
и вызываем в useEffect  
