# useEffect

## Эффекты состояния и пропсы

Эффекты всегда видят пропсы и состояния из того рендера,  
в котором они объявлены.  
Стейты и пропсы, внутри каждого рендера, являются константой  
и со временем не меняются.  

React вызывает компонент всякий раз, при обновлении стейта или пропсов.  
Компонент меняется и при каждом рендере вызывается снова и снова.  
При этом каждый рендер «видит» собственное значение стейта и пропсов,  
которое оказывается изолированным для каждой из операций рендеринга.  

Так же обработчики событий и другие ассинхронные операции, которые в своём коде  
ссылаются на значения стейта или пропсов, при своём исполнении будут  
использовать те варианты стейтов и пропсов, которые будут доступны им  
из замыкания. Т.е. те варианты, которые обработчики видели при своём объявлении  
(а не текущее их значение)  

Это связано с тем что useState не мутирует значение стейта, а для каждого  
рендера создаётся своё константное уникальное значение.  
Это отличает useState от setState в классовых компонентах  
(т.к. setState мутирует значение стейта)  
Чтобы в функциональных компонентах добиться поведения setState классовых  
компонентов, следует использовать useRef, значение которого мутируется  
и передаётся из рендера в рендер.  

Callback`и отмонтирования (функции возвращаемые из useEffect) так же видят  
те значения стейта, которые были актуальны на момент того варианта рендера,  
внутри которого useEffect был объявлен  
Но вызывается callback отмонтирования, после этапа рендера нового компонента,  
но перед вызовом useState  

## Этапы рендера компонента

1. Вызов компонента;  
2. useState возвращает обновлённое значение стейта;  
3. Обновляется virtual DOM и DOM;  
4. useLayoutEffect();  
5. render();  
6. Вызывается эффект отмонтирования прошлого useEffect;  
7. useEffect();  

