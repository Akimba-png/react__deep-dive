# useState

const [ smthg, setSmthg ] = useState( initializer )  
initializer - любое значение или чистая функция не принимающая аргументов  

Передавать следует именно объявление функции, а не её вызов. В этом случае  
она будет вызвана лишь единожды, при инициализации компонента, и не будет  
вызываться на каждый перерендер. Если передать вызов функции, то функция будет  вызываться на каждый перерендер компонента  

const [ smthg, setSmthg ] = useState( () => createSmthg()  ) - правильно  
const [ smthg, setSmthg ] = useState(  createSmthg()  ) - неправильно  

## Обновление стейта

setSmthg('newState')   ||   setSmthg( (prev) => prev + 1  )  

### Важные замечания:

1. Каждый рендер видит только своё значение стейта, которое является  
неизменным. Если после вызова setState('new'), в том же обработчике события  
обратиться к state, он будет равен предыдущему значению стейта  

2. Если setState сетит тоже значение, что и текущий state, то ререндера  
не будет setState('new) === state Важно помнить, что массивы и объекты  
передаются по ссылке и будут вызывать ререндер (т.к. они будут являться  
новым объектом)  

3. Батчинг. Ререндер компонента происходит единожды и только после  
выполнения всего кода во всех вызыванных обработчиках событий  
In the rare case that you need to force React to update the screen earlier,  
for example to access the DOM, you can use flushSync.  

Если в событийном обработчике обновляются несколько стейтов, то все  
обновления будут объединены в один ререндер  

Если в событийном обработчике обновляется последовательно один и тотже стейт,  
то все его setState() будут помещены в единую очередь, элементы которой будут  
последовательно выполнены после выполения всего кода в обработчике и итоговый  
результат будет отображён единым рендером  

Важно помнить, что в рамках одного рендера значение стейта неизменно.  
И если setState через замещение будет обращаться к текущему стейту, то там  
всегда будет константное значение текущего рендера  

setState(5) actually works like setState(n => 5), but n is unused!  

В пределах одного обработчике события может быть только один ререндер  
(но стейт в нём можно обновлять несколько раз через функциональное обновление)  

два setState в одном handler === batching Но два user click on handler  
with one set state === no batching  

4. setState() можно вызывать во время рендеринга компонента,  
т.е. не в обработчике события или в useEffectе, а не посредственно в теле  
компонента, но обязательно в if else  

Может потребовать для хранения и доступа к значению стейта  
с предыдущего рендера  
В этом случае реакт прочтёт setState в if else дойдёт до ближайшего return  
и выполнит ререндер, при этом children отрисованы не будут  

5. Object или Array в стейте можно хранить в стейте объеты или массивы. Но они  
подразумеваются как read-only. Т.е. при обновлении стейта всегда нужно  
передавать новый объект или массив, а не мутировать его (изменять какое-либо  
его поле) В противном случае ререндер может не произойти. Мутировать нельзя.  
Всегда передавать новый объект или массив  

6. Сброс (резет) стейта до начального значения  
Происходит при удалении компонента из dom  
(допустим если в родительском компоненте меняется isVisible && ChildComponent  
Если в дочернем компоненте менять стейт, потом в родительском компоненте  
поменять значение isVisible, то дочерний компонент удалится из dom,  
при повторной отрисовке стейт дочернего компонента обнулится на начальное  
значение)  

проп key  
Сброс стейта дочернего компонента происходит при передаче ему и при изменении  
пропа key. Если key изменён значит это новый экземпляр компонента и его стейт  
должен равняться начальному значению childComponent key={value}  
